<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端性能优化 | 面试指南</title>
    <meta name="description" content="">
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.cc2a2ebf.css" as="style"><link rel="preload" href="/assets/js/app.17e7384b.js" as="script"><link rel="preload" href="/assets/js/17.f5236e37.js" as="script"><link rel="prefetch" href="/assets/js/13.b419daba.js"><link rel="prefetch" href="/assets/js/2.cda51ec0.js"><link rel="prefetch" href="/assets/js/3.ef3ee796.js"><link rel="prefetch" href="/assets/js/4.2e46cd24.js"><link rel="prefetch" href="/assets/js/5.bec878ff.js"><link rel="prefetch" href="/assets/js/6.539a2935.js"><link rel="prefetch" href="/assets/js/7.22ed9e45.js"><link rel="prefetch" href="/assets/js/8.7646f7cd.js"><link rel="prefetch" href="/assets/js/9.7f41828b.js"><link rel="prefetch" href="/assets/js/10.dc5d0640.js"><link rel="prefetch" href="/assets/js/11.194957a4.js"><link rel="prefetch" href="/assets/js/12.9ae0f5ed.js"><link rel="prefetch" href="/assets/js/14.e6b680b7.js"><link rel="prefetch" href="/assets/js/15.f4550f65.js"><link rel="prefetch" href="/assets/js/16.6c41112e.js"><link rel="prefetch" href="/assets/js/18.7b2decb8.js"><link rel="prefetch" href="/assets/js/19.45ef936f.js"><link rel="prefetch" href="/assets/js/20.b6776b5a.js"><link rel="prefetch" href="/assets/js/21.5ddbd38c.js"><link rel="prefetch" href="/assets/js/22.d6bb9334.js"><link rel="prefetch" href="/assets/js/23.17390f50.js"><link rel="prefetch" href="/assets/js/24.3b2112ec.js"><link rel="prefetch" href="/assets/js/25.b6fac30f.js"><link rel="prefetch" href="/assets/js/26.dbe699e8.js"><link rel="prefetch" href="/assets/js/27.3f5a9dee.js"><link rel="prefetch" href="/assets/js/28.3514e3df.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cc2a2ebf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">面试指南</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end/" class="nav-link router-link-active">前端</a></div><div class="nav-item"><a href="/calculation/" class="nav-link">计算机基础</a></div><div class="nav-item"><a href="/interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="https://github.com/lufangyong" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end/" class="nav-link router-link-active">前端</a></div><div class="nav-item"><a href="/calculation/" class="nav-link">计算机基础</a></div><div class="nav-item"><a href="/interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="https://github.com/lufangyong" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/front-end/" class="sidebar-link">前端</a></li><li><a href="/front-end/js.html" class="sidebar-link">JS</a></li><li><a href="/front-end/browser.html" class="sidebar-link">Browser</a></li><li><a href="/front-end/css.html" class="sidebar-link">CSS</a></li><li><a href="/front-end/frame.html" class="sidebar-link">框架</a></li><li><a href="/front-end/fe-ngineering.html" class="sidebar-link">前端工程化</a></li><li><a href="/front-end/performance.html" class="active sidebar-link">前端性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end/performance.html#单页面应用的优缺点" class="sidebar-link">单页面应用的优缺点</a></li><li class="sidebar-sub-header"><a href="/front-end/performance.html#移动端-web-的兼容性-bug" class="sidebar-link">移动端 web 的兼容性 bug</a></li><li class="sidebar-sub-header"><a href="/front-end/performance.html#浏览器渲染原理解析" class="sidebar-link">浏览器渲染原理解析</a></li><li class="sidebar-sub-header"><a href="/front-end/performance.html#重绘与回流" class="sidebar-link">重绘与回流</a></li><li class="sidebar-sub-header"><a href="/front-end/performance.html#从输入-url-到页面展现" class="sidebar-link">从输入 URL 到页面展现</a></li><li class="sidebar-sub-header"><a href="/front-end/performance.html#缓存，存储相关" class="sidebar-link">缓存，存储相关</a></li><li class="sidebar-sub-header"><a href="/front-end/performance.html#页面缓存原理" class="sidebar-link">页面缓存原理</a></li><li class="sidebar-sub-header"><a href="/front-end/performance.html#cdn-工作原理" class="sidebar-link">CDN 工作原理</a></li><li class="sidebar-sub-header"><a href="/front-end/performance.html#网络优化-性能优化" class="sidebar-link">网络优化/性能优化</a></li><li class="sidebar-sub-header"><a href="/front-end/performance.html#缓存相关" class="sidebar-link">缓存相关</a></li><li class="sidebar-sub-header"><a href="/front-end/performance.html#首屏优化" class="sidebar-link">首屏优化</a></li><li class="sidebar-sub-header"><a href="/front-end/performance.html#前端渲染的优势" class="sidebar-link">前端渲染的优势</a></li><li class="sidebar-sub-header"><a href="/front-end/performance.html#服务端渲染的优势" class="sidebar-link">服务端渲染的优势</a></li></ul></li><li><a href="/front-end/http.html" class="sidebar-link">http</a></li><li><a href="/front-end/safe.html" class="sidebar-link">安全</a></li><li><a href="/front-end/design-pattern.html" class="sidebar-link">设计模式</a></li><li><a href="/front-end/node.html" class="sidebar-link">Node</a></li><li><a href="/front-end/recommend.html" class="sidebar-link">学习资源</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="前端性能优化"><a href="#前端性能优化" aria-hidden="true" class="header-anchor">#</a> 前端性能优化</h1> <ul><li>前端长列表的性能优化</li> <li>只渲染页面用用户能看到的部分。并且在不断滚动的过程中去除不在屏幕中的元素，不再渲染，从而实现高性能的列表渲染。</li> <li>借鉴着这个想法，我们思考一下。当列表不断往下拉时，web 中的 dom 元素就越多，即使这些 dom 元素已经离开了这个屏幕，不被用户所看到了，这些 dom 元素依然存在在那里。导致浏览器在渲染时需要不断去考虑这些 dom 元素的存在，造成 web 浏览器的长列表渲染非常低效。因此，实现的做法就是捕捉 scroll 事件，当 dom 离开屏幕，用户不再看到时，就将其移出 dom tree。</li> <li><a href="https://csspod.com/frontend-performance-best-practices/" target="_blank" rel="noopener noreferrer">前端性能优化最佳实践<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="单页面应用的优缺点"><a href="#单页面应用的优缺点" aria-hidden="true" class="header-anchor">#</a> 单页面应用的优缺点</h2> <p>优点：</p> <ol><li>用户体验好，快，内容的改变不需要重新加载整个页面</li> <li>基于上面一点，SPA 相对服务器压力小</li> <li>没有页面切换，就没有白屏阻塞</li></ol> <p>缺点：</p> <ol><li>不利于 SEO</li> <li>初次加载耗时增多</li> <li>导航不可用</li> <li>容易造成 css 命名冲突等</li> <li>页面复杂度提高很多，复杂逻辑难度成倍</li></ol> <p>为什么不利于 SEO？</p> <p>SPA 简单流程，蜘蛛无法执行 JS，相应的页面内容无从抓取</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">data-ng-app</span><span class="token attr-value"><span class="token punctuation">=</span>”app”</span><span class="token punctuation">&gt;</span></span>是其标志性的标注。
</code></pre></div><p>对于这种页面来说，很多都是采用 js 等搜索引擎无法识别的技术来做的</p> <h2 id="移动端-web-的兼容性-bug"><a href="#移动端-web-的兼容性-bug" aria-hidden="true" class="header-anchor">#</a> 移动端 web 的兼容性 bug</h2> <ol><li>一些情况下对非可点击元素如(label,span)监听 click 事件，ios 下不会触发，css 增加 cursor:pointer 就搞定了。</li> <li>position 在 Safari 下的两个定位需要都写，只写一个容易发生错乱</li> <li>Input 的 placeholder 会出现文本位置偏上的情况,input 的 placeholder 会出现文本位置偏上的情况：PC 端设置 line-height 等于 height 能够对齐，而移动端仍然是偏上，解决是设置 line-height：normal</li> <li>zepto 点击穿透问题,引入 fastclick 解决；event.preventDefault</li> <li>当输入框在最底部的时候，弹起的虚拟键盘会把输入框挡住。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>Element<span class="token punctuation">.</span><span class="token function">scrollIntoViewIfNeeded</span><span class="token punctuation">(</span>opt_center<span class="token punctuation">)</span>
</code></pre></div><h2 id="浏览器渲染原理解析"><a href="#浏览器渲染原理解析" aria-hidden="true" class="header-anchor">#</a> 浏览器渲染原理解析</h2> <ol><li>首先渲染引擎下载 HTML，解析生成 DOM Tree</li> <li>遇到 css 标签或 JS 脚本标签就新起线程去下载他们，并继续构建 DOM。（其中 css 是异步下载同步执行）浏览器引擎通过 DOM Tree 和 CSS Rule Tree 构建 Rendering Tree</li> <li>通过 CSS Rule Tree 匹配 DOM Tree 进行定位坐标和大小，这个过程称为 Flow 或 Layout 。</li> <li>最终通过调用 Native GUI 的 API 绘制网页画面的过程称为 Paint 。</li></ol> <h2 id="重绘与回流"><a href="#重绘与回流" aria-hidden="true" class="header-anchor">#</a> 重绘与回流</h2> <ul><li>当用户在浏览网页时进行交互或通过 js 脚本改变页面结构时，以上的部分操作有可能重复运行，此过程称为 Repaint 或 Reflow。</li> <li>回流是指 dom 树发生结构变化后，需要重新构建 dom 结构。</li> <li>重绘是指 dom 节点样式改变，重新绘制。</li> <li>回流定会带来重绘，重绘不一定有回流。</li></ul> <p>如何减少浏览器回流：将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。</p> <h2 id="从输入-url-到页面展现"><a href="#从输入-url-到页面展现" aria-hidden="true" class="header-anchor">#</a> 从输入 URL 到页面展现</h2> <p>发生 HTTP 请求的过程</p> <p>HTTP 是一个基于请求与响应，无状态的，应用层的协议，常基于 TCP/IP 协议传输数据。</p> <ul><li>1.域名解析，查找缓存
<ul><li>查找浏览器缓存（DNS 缓存）</li> <li>查找操作系统缓存（如果浏览器缓存没有，浏览器会从 hosts 文件查找是否有 DNS 信息）</li> <li>查找路由器缓存</li> <li>查找 ISP 缓存</li></ul></li> <li>2.浏览器获得对应的 ip 地址后，浏览器与远程<code>Web</code>服务器通过<code>TCP</code>三次握手协商来建立一个<code>TCP/IP</code>连接。</li> <li>3.TCP/IP 连接建立起来后，浏览器就可以向服务器发送 HTTP 请求</li> <li>4.服务器处理请求，返回资源（MVC 设计模式）</li> <li>5.浏览器处理（加载，解析，渲染）
<ul><li>HTML 页面加载顺序从上而下</li> <li>解析文档为有意义的结构，DOM 树；解析 css 文件为样式表对象</li> <li>渲染。将 DOM 树进行可视化表示</li></ul></li> <li>6.绘制网页
<ul><li>浏览器根据 HTML 和 CSS 计算得到渲染数，最终绘制到屏幕上</li></ul></li></ul> <p>一个完整 HTTP 请求的过程为：</p> <ul><li>DNS Resolving -&gt; TCP handshake -&gt; HTTP Request -&gt; Server -&gt; HTTP Response -&gt; TCP shutdown</li></ul> <p><a href="https://segmentfault.com/a/1190000006879700#articleHeader7" target="_blank" rel="noopener noreferrer">从输入 URL 到页面加载发生了什么？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="缓存，存储相关"><a href="#缓存，存储相关" aria-hidden="true" class="header-anchor">#</a> 缓存，存储相关</h2> <p>cookie、localStorage、sessionStorage</p> <p>cookie 优点：</p> <ol><li>可以解决 HTTP 无状态的问题，与服务器进行交互</li></ol> <p>缺点：</p> <ol><li>数量和长度限制，每个域名最多 20 条，每个 cookie 长度不能超过 4kb</li> <li>安全性问题。容易被人拦截</li> <li>浪费带宽，每次请求新页面，cookie 都会被发送过去</li></ol> <p>cookie 和 session 区别</p> <ol><li>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</li> <li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用 COOKIE。</li> <li>sessionStorage 是当前对话的缓存，浏览器窗口关闭即消失，localStorage 持久存在，除非清除浏览器缓存。</li></ol> <h2 id="页面缓存原理"><a href="#页面缓存原理" aria-hidden="true" class="header-anchor">#</a> 页面缓存原理</h2> <p>页面缓存状态是由 http header 决定的，一个浏览器请求信息，一个是服务器响应信息。</p> <p>主要包括 Pragma:</p> <ul><li>no-cache、Cache-Control、 Expires、 Last-Modified、If-Modified-Since。</li></ul> <h2 id="cdn-工作原理"><a href="#cdn-工作原理" aria-hidden="true" class="header-anchor">#</a> CDN 工作原理</h2> <p>CDN 做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源</p> <p>CDN 的工作原理：通过 dns 服务器来实现优质节点的选择，通过缓存来减少源站的压力。</p> <h2 id="网络优化-性能优化"><a href="#网络优化-性能优化" aria-hidden="true" class="header-anchor">#</a> 网络优化/性能优化</h2> <ul><li>使用 CDN，让用户访问最近的资源，减少来回传输时间</li> <li>合并压缩 CSS、js、图片、静态资源，服务器开启 GZIP</li> <li>css 放顶部，js 放底部（css 可以并行下载，而 js 加载之后会造成阻塞）</li> <li>图片预加载和首屏图片之外的做懒加载</li> <li>做 HTTP 缓存（添加 Expires 头和配置 Etag）用户可以重复使用本地缓存，减少对服务器压力</li> <li>大小超过 10KB 的 css/img 建议外联引用，以细化缓存粒度</li> <li>小于 10k 的图片 base64</li> <li>DNS 预解析 DNS-Prefetch</li> <li>预连接 Preconnect</li></ul> <p>代码层面优化</p> <p>少用全局变量，减少作用域链查找，缓存 DOM 查找结果，避免使用 with（with 会创建自己的作用域，会增加作用域链长度）；多个变量声明合并；减少 DOM 操作次数；尽量避免在 HTML 标签中写 style 属性</p> <p>避免使用 css3 渐变阴影效果，尽量使用 css3 动画，开启硬件加速，不滥用 float；避免使用 CSS 表达式；使用<code>&lt;link&gt;</code>来代替<code>@import</code></p> <p>图片预加载原理</p> <p>提前加载图片，当用户需要查看时可直接从本地缓存中渲染</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> imgArr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">&quot;1.jpg&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;2.jpg&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">loadImage</span><span class="token punctuation">(</span>imgArr<span class="token punctuation">,</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">loadImage</span><span class="token punctuation">(</span>imgArr<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> imgNum<span class="token operator">=</span>imgArr<span class="token punctuation">.</span>length<span class="token punctuation">,</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>imgNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">var</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建一个Image对象，实现图片的预下载</span>
      img<span class="token punctuation">.</span>src <span class="token operator">=</span> imgArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>img<span class="token punctuation">.</span>complete<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果图片已经存在于浏览器缓存，直接调用回调函数</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span>imgNum<span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 直接返回，不用再处理onload事件</span>
         <span class="token punctuation">}</span>
 <span class="token punctuation">}</span> count<span class="token operator">++</span><span class="token punctuation">;</span> img<span class="token punctuation">.</span><span class="token function-variable function">onload</span><span class="token operator">=</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span>imgNum<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment">//for循环结束}</span>
</code></pre></div><h2 id="缓存相关"><a href="#缓存相关" aria-hidden="true" class="header-anchor">#</a> 缓存相关</h2> <ol><li>浏览器输入 url 之后敲下回车，刷新 F5 与强制刷新(Ctrl + F5)，又有什么区别？</li></ol> <p>实际上浏览器输入 url 之后敲下回车就是先看本地 cache-control、expires 的情况，刷新(F5)就是忽略先看本地 cache-control、expires 的情况，带上条件 If-None-Match、If-Modified-Since，强制刷新(Ctrl + F5)就是不带条件的访问。</p> <ol start="2"><li>etag，cache-control，last-modified</li></ol> <p>如果比较粗的说先后顺序应该是这样：</p> <ul><li>Cache-Control —— 请求服务器之前</li> <li>Expires —— 请求服务器之前</li> <li>If-None-Match (Etag) —— 请求服务器</li> <li>If-Modified-Since (Last-Modified) —— 请求服务器</li></ul> <p>需要注意的是 如果同时有 etag 和 last-modified 存在，在发送请求的时候会一次性的发送给服务器，没有优先级，服务器会比较这两个信息.</p> <p>如果 expires 和 cache-control:max-age 同时存在，expires 会被 cache-control 覆盖。</p> <p>其中 Expires 和 cache-control 属于强缓存，last-modified 和 etag 属于协商缓存
强缓存与协商缓存区别：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p> <h2 id="首屏优化"><a href="#首屏优化" aria-hidden="true" class="header-anchor">#</a> 首屏优化</h2> <p>再回到前端渲染遇到首屏渲染问题，除了同构就没有其它解法了吗？总结以下可以通过以下三步解决</p> <p>分拆打包</p> <p>现在流行的路由库如 react-router 对分拆打包都有很好的支持。可以按照页面对包进行分拆，并在页面切换时加上一些 loading 和 transition 效果。</p> <ol><li>首屏内容最好做到静态缓存</li> <li>首屏内联 css 渲染</li> <li>图片懒加载</li> <li>服务端渲染，首屏渲染速度更快（重点），无需等待 js 文件下载执行的过程</li> <li>交互优化（使用加载占位器，在白屏无法避免的时候，为了解决等待加载过程中白屏或者界面闪烁）</li> <li>图片尺寸大小控制</li></ol> <h2 id="前端渲染的优势"><a href="#前端渲染的优势" aria-hidden="true" class="header-anchor">#</a> 前端渲染的优势</h2> <ul><li>局部刷新。无需每次都进行完整页面请求</li> <li>懒加载。如在页面初始时只加载可视区域内的数据，滚动后 rp 加载其它数据，可以通过 react-lazyload 实现</li> <li>富交互。使用 JS 实现各种酷炫效果</li> <li>节约服务器成本。省电省钱，JS 支持 CDN 部署，且部署极其简单，只需要服务器支持静态文件即可</li> <li>天生的关注分离设计。服务器来访问数据库提供接口，JS 只关注数据获取和展现</li> <li>JS 一次学习，到处使用。可以用来开发 Web、Serve、Mobile、Desktop 类型的应用</li></ul> <h2 id="服务端渲染的优势"><a href="#服务端渲染的优势" aria-hidden="true" class="header-anchor">#</a> 服务端渲染的优势</h2> <ul><li>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</li> <li>服务端渲染不需要先下载一堆 js 和 css 后才能看到页面（首屏性能）</li> <li>服务端渲染不用关心浏览器兼容性问题（随意浏览器发展，这个优点逐渐消失）</li> <li>对于电量不给力的手机或平板，减少在客户端的电量消耗很重要</li></ul></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/front-end/fe-ngineering.html" class="prev">
          前端工程化
        </a></span> <span class="next"><a href="/front-end/http.html">
          http
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/17.f5236e37.js" defer></script><script src="/assets/js/app.17e7384b.js" defer></script>
  </body>
</html>
