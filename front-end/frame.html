<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>框架 | 面试指南</title>
    <meta name="description" content="">
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.cc2a2ebf.css" as="style"><link rel="preload" href="/assets/js/app.17e7384b.js" as="script"><link rel="preload" href="/assets/js/13.b419daba.js" as="script"><link rel="prefetch" href="/assets/js/2.cda51ec0.js"><link rel="prefetch" href="/assets/js/3.ef3ee796.js"><link rel="prefetch" href="/assets/js/4.2e46cd24.js"><link rel="prefetch" href="/assets/js/5.bec878ff.js"><link rel="prefetch" href="/assets/js/6.539a2935.js"><link rel="prefetch" href="/assets/js/7.22ed9e45.js"><link rel="prefetch" href="/assets/js/8.7646f7cd.js"><link rel="prefetch" href="/assets/js/9.7f41828b.js"><link rel="prefetch" href="/assets/js/10.dc5d0640.js"><link rel="prefetch" href="/assets/js/11.194957a4.js"><link rel="prefetch" href="/assets/js/12.9ae0f5ed.js"><link rel="prefetch" href="/assets/js/14.e6b680b7.js"><link rel="prefetch" href="/assets/js/15.f4550f65.js"><link rel="prefetch" href="/assets/js/16.6c41112e.js"><link rel="prefetch" href="/assets/js/17.f5236e37.js"><link rel="prefetch" href="/assets/js/18.7b2decb8.js"><link rel="prefetch" href="/assets/js/19.45ef936f.js"><link rel="prefetch" href="/assets/js/20.b6776b5a.js"><link rel="prefetch" href="/assets/js/21.5ddbd38c.js"><link rel="prefetch" href="/assets/js/22.d6bb9334.js"><link rel="prefetch" href="/assets/js/23.17390f50.js"><link rel="prefetch" href="/assets/js/24.3b2112ec.js"><link rel="prefetch" href="/assets/js/25.b6fac30f.js"><link rel="prefetch" href="/assets/js/26.dbe699e8.js"><link rel="prefetch" href="/assets/js/27.3f5a9dee.js"><link rel="prefetch" href="/assets/js/28.3514e3df.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cc2a2ebf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">面试指南</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end/" class="nav-link router-link-active">前端</a></div><div class="nav-item"><a href="/calculation/" class="nav-link">计算机基础</a></div><div class="nav-item"><a href="/interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="https://github.com/lufangyong" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end/" class="nav-link router-link-active">前端</a></div><div class="nav-item"><a href="/calculation/" class="nav-link">计算机基础</a></div><div class="nav-item"><a href="/interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="https://github.com/lufangyong" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/front-end/" class="sidebar-link">前端</a></li><li><a href="/front-end/js.html" class="sidebar-link">JS</a></li><li><a href="/front-end/browser.html" class="sidebar-link">Browser</a></li><li><a href="/front-end/css.html" class="sidebar-link">CSS</a></li><li><a href="/front-end/frame.html" class="active sidebar-link">框架</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end/frame.html#react-和-vue-的区别" class="sidebar-link">react 和 vue 的区别</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#react" class="sidebar-link">react</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end/frame.html#react-的优缺点" class="sidebar-link">react 的优缺点</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#jsx-的优缺点" class="sidebar-link">jsx 的优缺点</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#dom-diff-算法和虚拟-dom" class="sidebar-link">dom diff 算法和虚拟 DOM</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#react-组件性能优化" class="sidebar-link">react 组件性能优化</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#react-组件间的数据传递" class="sidebar-link">react 组件间的数据传递</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#无状态组件" class="sidebar-link">无状态组件</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#高阶组件" class="sidebar-link">高阶组件</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#react-事件和传统事件有什么区别吗" class="sidebar-link">react 事件和传统事件有什么区别吗</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#react-组件生命周期" class="sidebar-link">react 组件生命周期</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#vue" class="sidebar-link">vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end/frame.html#vue-双向绑定底层实现原理" class="sidebar-link">vue 双向绑定底层实现原理</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#vue-虚拟-dom-和-react-虚拟-dom-的区别" class="sidebar-link">vue 虚拟 DOM 和 react 虚拟 DOM 的区别</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#v-show-和-v-if-区别" class="sidebar-link">v-show 和 v-if 区别</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#vue-组件通信" class="sidebar-link">vue 组件通信</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#你如何评价-vue" class="sidebar-link">你如何评价 vue</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#说说你对-mvvm-的理解" class="sidebar-link">说说你对 MVVM 的理解</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#为什么选择-vue" class="sidebar-link">为什么选择 vue</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#vue-中-mixin-与-extend-区别" class="sidebar-link">vue 中 mixin 与 extend 区别</a></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#双向绑定和单向数据绑定的优缺点" class="sidebar-link">双向绑定和单向数据绑定的优缺点</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end/frame.html#前端路由实现方式" class="sidebar-link">前端路由实现方式</a></li></ul></li><li><a href="/front-end/fe-ngineering.html" class="sidebar-link">前端工程化</a></li><li><a href="/front-end/performance.html" class="sidebar-link">前端性能优化</a></li><li><a href="/front-end/http.html" class="sidebar-link">http</a></li><li><a href="/front-end/safe.html" class="sidebar-link">安全</a></li><li><a href="/front-end/design-pattern.html" class="sidebar-link">设计模式</a></li><li><a href="/front-end/node.html" class="sidebar-link">Node</a></li><li><a href="/front-end/recommend.html" class="sidebar-link">学习资源</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="框架"><a href="#框架" aria-hidden="true" class="header-anchor">#</a> 框架</h1> <p>vue 官方：<a href="https://cn.vuejs.org/v2/guide/comparison.html" target="_blank" rel="noopener noreferrer">对比其他框架<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="react-和-vue-的区别"><a href="#react-和-vue-的区别" aria-hidden="true" class="header-anchor">#</a> react 和 vue 的区别</h2> <p>相同点：</p> <ul><li>都支持服务端渲染</li> <li>都有 Virtual DOM，组件化开发，通过 props 参数进行父子组件数据的传递，都实现 webComponents 规范</li> <li>数据驱动视图</li> <li>都有支持 native 的方案，React 的 React native，Vue 的 weex</li></ul> <p>不同点：</p> <ul><li>React 严格上只针对 MVC 的 view 层，Vue 则是 MVVM 模式</li> <li>virtual DOM 不一样
vue 会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对于 React 而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 shouldComponentUpdate 这个生命周期方法来进行控制，</li> <li>组件写法不一样
React 推荐的做法是 JSX + inline style，也就是把 HTML 和 CSS 全都写进 JavaScript 了，即”all in js”
Vue 推荐的是使用 <code>webpack + vue-loader</code> 的单文件组件格式，即 html,css,js 写在同一个文件；</li> <li>数据绑定：Vue 有实现了双向数据绑定，React 数据流动是单向的</li> <li>state 对象在 react 应用中是不可变的，需要使用 setState 方法更新状态；在 Vue 中，state 对象并不是必须的，数据由 data 属性在 Vue 对象中进行管理。</li></ul> <h2 id="react"><a href="#react" aria-hidden="true" class="header-anchor">#</a> react</h2> <h3 id="react-的优缺点"><a href="#react-的优缺点" aria-hidden="true" class="header-anchor">#</a> react 的优缺点</h3> <p>我觉得这优缺点就因人而异，见仁见智了。</p> <p>优点：</p> <ul><li>可以通过函数式方法描述视图组件（好处：相同的输入会得到同样的渲染结果，不会有副作用；组件不会被实例化，整体渲染性能得到提升）</li> <li>集成虚拟 DOM（性能好）</li> <li>单向数据流（好处是更容易追踪数据变化排查问题</li> <li>一切都是 component：代码更加模块化，重用代码更容易，可维护性高</li> <li>大量拥抱 es6 新特性</li> <li>jsx</li></ul> <p>缺点：</p> <ul><li>jsx 的一个问题是，渲染函数常常包含大量逻辑，最终看着更像是程序片段，而不是视觉呈现。后期如果发生需求更改，维护起来工作量将是巨大的</li> <li>大而全，上手有难度</li></ul> <h3 id="jsx-的优缺点"><a href="#jsx-的优缺点" aria-hidden="true" class="header-anchor">#</a> jsx 的优缺点</h3> <ul><li>允许使用熟悉的语法来定义 HTML 元素树</li> <li>JSX 让小组件更加简单、明了、直观。</li> <li>更加语义化且易懂的标签</li> <li>JSX 本质是对 JavaScript 语法的一个扩展，看起来像是某种模板语言，但其实不是。但正因为形似 HTML，描述 UI 就更直观了，也极大地方便了开发；</li> <li>在 React 中 babel 会将 JSX 转换为<code>React.createElement</code>函数调用，然后将 JSX 转换为正确的 JSON 对象（VDOM 也是一个“树”形的结构）</li> <li>React/JSX 乍看之下，觉得非常啰嗦，但使用 JavaScript 而不是模板语法来开发（模板语法比较有局限性），赋予了开发者许多编程能力。</li></ul> <h3 id="dom-diff-算法和虚拟-dom"><a href="#dom-diff-算法和虚拟-dom" aria-hidden="true" class="header-anchor">#</a> dom diff 算法和虚拟 DOM</h3> <p>React 中的 render 方法，返回一个 DOM 描述，结果仅仅是轻量级的 js 对象。</p> <p>Reactjs 只在调用 setState 的时候会更新 dom，而且还是先更新 Virtual Dom，然后和实际 DOM 比较，最后再更新实际 DOM。</p> <p>React.js 厉害的地方并不是说它比 DOM 快（这句话本来就是错的），而是说不管你数据怎么变化，我都可以以最小的代价来更新 DOM。方法就是我在内存里面用新的数据刷新一个虚拟的 DOM 树，然后新旧 DOM 树进行比较，找出差异，再更新到真正的 DOM 树上。</p> <p>当我们修改了 DOM 树上一些节点对应绑定的 state，React 会立即将它标记为“脏状态”。在事件循环的最后才重新渲染所有的脏节点。在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面，最后把差异应用到真正的 DOM 树上。</p> <p>算法实现</p> <ol><li>步骤一：用 JS 对象模拟 DOM 树</li> <li>步骤二：比较两棵虚拟 DOM 树的差异</li> <li>步骤三：把差异应用到真正的 DOM 树上</li></ol> <p>这就是所谓的 diff 算法</p> <p>dom diff 采用的是增量更新的方式，类似于打补丁。React 需要为数据添加 key 来保证虚拟 DOM diff 算法的效率。key 属性可以帮助 React 定位到正确的节点进行比较，从而大幅减少 DOM 操作次数，提高了性能。</p> <p><code>virtual dom</code>，也就是虚拟节点。它通过 JS 的 Object 对象模拟 DOM 中的节点，然后再通过特定的 render 方法将其渲染成真实的 DOM 节点。</p> <p><a href="http://react-china.org/t/dom/638" target="_blank" rel="noopener noreferrer">怎么更好的理解虚拟 dom?<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h4 id="为什么-js-对象模拟-dom-会比-js-操作-dom-来得快"><a href="#为什么-js-对象模拟-dom-会比-js-操作-dom-来得快" aria-hidden="true" class="header-anchor">#</a> 为什么 js 对象模拟 DOM 会比 js 操作 DOM 来得快</h4> <p>为了解决频繁操作 DOM 导致 Web 应用效率下降的问题，React 提出了“虚拟 DOM”（virtual DOM）的概念。Virtual DOM 是使用 JavaScript 对象模拟 DOM 的一种对象结构。DOM 树中所有的信息都可以用 JavaScript 表述出来，例如：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Item 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Item 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Item 3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>可以用以下 JavaScript 对象来表示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  tag<span class="token punctuation">:</span> <span class="token string">'ul'</span><span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
    tag<span class="token punctuation">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span> children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Item 1'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    tag<span class="token punctuation">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span> children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Item 2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    tag<span class="token punctuation">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span> children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Item 3'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样可以避免直接频繁地操作 DOM，只需要在 js 对象模拟的虚拟 DOM 进行比对，再将更改的部分应用到真实的 DOM 树上</p> <h3 id="react-组件性能优化"><a href="#react-组件性能优化" aria-hidden="true" class="header-anchor">#</a> react 组件性能优化</h3> <p>使用 PureRenderMixin、shouldComponentUpdate 来避免不必要的虚拟 DOM diff，在 render 内部优化虚拟 DOM 的 diff 速度，以及让 diff 结果最小化。</p> <h3 id="react-组件间的数据传递"><a href="#react-组件间的数据传递" aria-hidden="true" class="header-anchor">#</a> react 组件间的数据传递</h3> <ol><li><p>兄弟组件不能直接相互传送数据，此时可以将数据挂载在父组件中，由两个组件共享</p></li> <li><p>子组件向父组件通讯，可以通过父组件定义事件（回调函数），子组件调用该函数，通过实参的形式来改变父组件的数据来通信</p></li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//子组件</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">onCommentSubmit</span><span class="token punctuation">(</span><span class="token punctuation">{</span>author<span class="token punctuation">,</span> content<span class="token punctuation">,</span> date<span class="token punctuation">:</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//父组件</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;m-index&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>评论<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>CommentList data<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>data<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>CommentForm onCommentSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleCommentSubmit<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>非父子组件间的通信：可以使用全局事件来实现组件间的沟通，React 中可以引入 eventProxy 模块，利用<code>eventProxy.trigger()</code>方法发布消息，<code>eventProxy.on()</code>方法监听并接收消息。</li> <li>组件间层级太深，可以使用上下文方式，让子组件直接访问祖先的数据或函数，通过<code>this.context.xx</code></li></ol> <h3 id="无状态组件"><a href="#无状态组件" aria-hidden="true" class="header-anchor">#</a> 无状态组件</h3> <p>无状态组件其实本质上就是一个函数，传入 props 即可，没有 state，也没有生命周期方法。组件本身对应的就是 render 方法。例子如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Title</span><span class="token punctuation">(</span><span class="token punctuation">{</span> color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span> text <span class="token operator">=</span> <span class="token string">'标题'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> style <span class="token operator">=</span> <span class="token punctuation">{</span>
    color<span class="token punctuation">:</span> color
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">{</span>style<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>text<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>无状态组件不会创建对象，故比较省内存。没有复杂的生命周期方法调用，故流程比较简单。没有 state，也不会重复渲染。它本质上就是一个函数而已。</p> <p>对于没有状态变化的组件，React 建议我们使用无状态组件。总之，能用无状态组件的地方，就用无状态组件。</p> <h3 id="高阶组件"><a href="#高阶组件" aria-hidden="true" class="header-anchor">#</a> 高阶组件</h3> <p>高阶组件（HOC）是函数接受一个组件，返回一个新组件。其前身其实是用 ES5 创建组件时可用的 mixin 方法，但是在 react 版本升级过程中，使用 ES6 语法创建组件时，认为 mixin 是反模式，影响了 react 架构组件的封装稳定性，增加了不可控的复杂度，逐渐被 HOC 所替代。
实现高阶组件的方式有：</p> <h4 id="属性代理"><a href="#属性代理" aria-hidden="true" class="header-anchor">#</a> 属性代理</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'React'</span>
<span class="token comment">//高阶组件定义</span>
<span class="token keyword">const</span> <span class="token function-variable function">HOC</span> <span class="token operator">=</span> WrappedComponent <span class="token operator">=&gt;</span>
  <span class="token keyword">class</span> <span class="token class-name">WrapperComponent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token comment">//普通的组件</span>
<span class="token keyword">class</span> <span class="token class-name">WrappedComponent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//....</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//高阶组件使用</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token constant">HOC</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span>
</code></pre></div><h4 id="反向继承"><a href="#反向继承" aria-hidden="true" class="header-anchor">#</a> 反向继承</h4> <p>反向继承是指返回的组件去继承之前的组件(这里都用 WrappedComponent 代指)</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">HOC</span> <span class="token operator">=</span> WrappedComponent <span class="token operator">=&gt;</span>
  <span class="token keyword">class</span> <span class="token class-name">extends</span> WrappedComponent <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>我们可以看见返回的组件确实都继承自 WrappedComponent,那么所有的调用将是反向调用的(例如:super.render())，这也就是为什么叫做反向继承。</p> <h3 id="react-事件和传统事件有什么区别吗"><a href="#react-事件和传统事件有什么区别吗" aria-hidden="true" class="header-anchor">#</a> react 事件和传统事件有什么区别吗</h3> <p>React 实现了一个“合成事件”层（synthetic event system），这个事件模型保证了和 W3C 标准保持一致，所以不用担心有什么诡异的用法，并且这个事件层消除了 IE 与 W3C 标准实现之间的兼容问题。</p> <p>“合成事件”还提供了额外的好处：</p> <p>事件委托</p> <p>“合成事件”会以事件委托（event delegation）的方式绑定到组件最上层，并且在组件卸载（unmount）的时候自动销毁绑定的事件。</p> <h3 id="react-组件生命周期"><a href="#react-组件生命周期" aria-hidden="true" class="header-anchor">#</a> react 组件生命周期</h3> <p>react 组件更新过程：</p> <p>props/state change：</p> <ol><li>componentWillReceiveProps(nextProps)</li></ol> <p>只要是父组件的 render 被调用，在 render 中被渲染的子组件就会经历更新的过程。不管父组件传给子组件的 props 有没有改变，都会触发子组件的此函数被调用。注意：通过 setState 方法触发的更新不会调用此函数</p> <ol start="2"><li>shouldComponentUpdate(nextProps,nextState)</li> <li>componentWillUpdate</li> <li>render</li> <li>componentDidUpdate</li></ol> <h2 id="vue"><a href="#vue" aria-hidden="true" class="header-anchor">#</a> vue</h2> <h3 id="vue-双向绑定底层实现原理"><a href="#vue-双向绑定底层实现原理" aria-hidden="true" class="header-anchor">#</a> vue 双向绑定底层实现原理</h3> <p>vue.js 采用数据劫持的方式，结合发布者-订阅者模式，通过<code>Object.defineProperty()</code>来劫持各个属性的 setter，getter 以监听属性的变动，在数据变动时发布消息给订阅者，触发相应的监听回调：</p> <p><a href="https://github.com/hawx1993/tech-blog/issues/11" target="_blank" rel="noopener noreferrer">关于 vue2.0 的实现源码剖析(一)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="vue-虚拟-dom-和-react-虚拟-dom-的区别"><a href="#vue-虚拟-dom-和-react-虚拟-dom-的区别" aria-hidden="true" class="header-anchor">#</a> vue 虚拟 DOM 和 react 虚拟 DOM 的区别</h3> <p>在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对于 React 而言，每当应用的状态被改变时，全部子组件都会重新渲染。
在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。</p> <p>如要避免不必要的子组件的重新渲染，你需要在所有可能的地方使用 PureComponent，或是手动实现<code>shouldComponentUpdate</code> 方法</p> <p>在 React 中，数据流是自上而下单向的从父节点传递到子节点，所以组件是简单且容易把握的，子组件只需要从父节点提供的 props 中获取数据并渲染即可。如果顶层组件的某个 prop 改变了，React 会递归地向下遍历整棵组件树，重新渲染所有使用这个属性的组件。</p> <h3 id="v-show-和-v-if-区别"><a href="#v-show-和-v-if-区别" aria-hidden="true" class="header-anchor">#</a> v-show 和 v-if 区别</h3> <p>与 v-if 不同的是，无论 v-show 的值为 true 或 false，元素都会存在于 HTML 代码中；而只有当 v-if 的值为 true，元素才会存在于 HTML 代码中</p> <h3 id="vue-组件通信"><a href="#vue-组件通信" aria-hidden="true" class="header-anchor">#</a> vue 组件通信</h3> <p>非父子组件间通信，Vue 有提供 Vuex，以状态共享方式来实现同信，对于这一点，应该注意考虑平衡，从整体设计角度去考量，确保引入她的必要。</p> <p>父传子: <code>this.$refs.xxx</code>
子传父: <code>this.$parent.xxx</code></p> <p>还可以通过<code>$emit</code>方法出发一个消息，然后<code>$on</code>接收这个消息</p> <h3 id="你如何评价-vue"><a href="#你如何评价-vue" aria-hidden="true" class="header-anchor">#</a> 你如何评价 vue</h3> <p>框架能够让我们跑的更快，但只有了解原生的 JS 才能让我们走的更远。</p> <p>vue 专注于 MVVM 中的 viewModel 层，通过双向数据绑定，把 view 层和 Model 层连接了起来。核心是用数据来驱动 DOM。这种把 directive 和 component 混在一起的设计有一个非常大的问题，它导致了很多开发者滥用 Directive（指令），出现了到处都是指令的情况。</p> <p>优点：</p> <ol><li>不需要 setState，直接修改数据就能刷新页面，而且不需要 react 的 shouldComponentUpdate 就能实现最高效的渲染路径。</li> <li>渐进式的开发模式，模版方式-&gt;组件方式-&gt;路由整合-&gt;数据流整合-&gt;服务器渲染。上手的曲线更加平滑简单，而且不像 react 一上来就是组件全家桶</li> <li>v-model 给开发后台管理系统带来极大的便利，反观用 react 开发后台就是个杯具</li> <li>html，css 与 js 比 react 更优雅地结合在一个文件上。</li></ol> <p>缺点：</p> <ol><li>指令太多</li> <li>自带模板扩展不方便</li> <li>组件的属性传递没有 react 的直观和明显</li></ol> <h3 id="说说你对-mvvm-的理解"><a href="#说说你对-mvvm-的理解" aria-hidden="true" class="header-anchor">#</a> 说说你对 MVVM 的理解</h3> <ul><li>Model 层代表数据模型，可以在 Model 中定义数据修改和操作业务逻辑；</li> <li>view 代表 UI 组件。负责将数据模型转换成 UI 展现出来</li> <li>ViewModel 是一个同步 View 和 Model 的对象</li></ul> <p>用户操作 view 层，view 数据变化会同步到 Model，Model 数据变化会立即反应到 view 中。viewModel 通过双向数据绑定把 view 层和 Model 层连接了起来</p> <h3 id="为什么选择-vue"><a href="#为什么选择-vue" aria-hidden="true" class="header-anchor">#</a> 为什么选择 vue</h3> <ul><li>reactjs 的全家桶方式，实在太过强势，而自己定义的 JSX 规范，揉和在 JS 的组件框架里，导致如果后期发生页面改版工作，工作量将会巨大。</li> <li>vue 的核心：数据绑定 和 视图组件。</li> <li>Vue 的数据驱动：数据改变驱动了视图的自动更新，传统的做法你得手动改变 DOM 来改变视图，vuejs 只需要改变数据，就会自动改变视图，一个字：爽。再也不用你去操心 DOM 的更新了，这就是 MVVM 思想的实现。</li> <li>视图组件化：把整一个网页的拆分成一个个区块，每个区块我们可以看作成一个组件。网页由多个组件拼接或者嵌套组成</li></ul> <h3 id="vue-中-mixin-与-extend-区别"><a href="#vue-中-mixin-与-extend-区别" aria-hidden="true" class="header-anchor">#</a> vue 中 mixin 与 extend 区别</h3> <p>全局注册混合对象，会影响到所有之后创建的 vue 实例，而<code>Vue.extend</code>是对单个实例进行扩展。</p> <p>mixin 混合对象（组件复用）</p> <p>同名钩子函数（bind，inserted，update，componentUpdate，unbind）将混合为一个数组，因此都将被调用，混合对象的钩子将在组件自身钩子之前调用</p> <p><code>methods</code>，<code>components</code>，<code>directives</code>将被混为同一个对象。两个对象的键名（方法名，属性名）冲突时，取组件（而非 mixin）对象的键值对</p> <h3 id="双向绑定和单向数据绑定的优缺点"><a href="#双向绑定和单向数据绑定的优缺点" aria-hidden="true" class="header-anchor">#</a> 双向绑定和单向数据绑定的优缺点</h3> <p>单向数据流</p> <ul><li>只有 UI 控件 才存在双向，非 UI 控件 只有单向。</li> <li>单向绑定的优点是可以带来单向数据流，这样的好处是流动方向可以跟踪，流动单一，没有状态, 这使得单向绑定能够避免状态管理在复杂度上升时产生的各种问题, 程序的调试会变得相对容易。</li> <li>单向数据流更利于状态的维护及优化，更利于组件之间的通信，更利于组件的复用</li></ul> <p>双向数据流的优点：</p> <p>无需进行和单向数据绑定的那些 CRUD（Create，Retrieve，Update，Delete）操作；
双向绑定在一些需要实时反应用户输入的场合会非常方便
用户在视图上的修改会自动同步到数据模型中去，数据模型中值的变化也会立刻同步到视图中去；</p> <p>双向数据流的缺点：</p> <ul><li>双向数据流是自动管理状态的, 但是在实际应用中会有很多不得不手动处理状态变化的逻辑, 使得程序复杂度上升无法追踪局部状态的变化</li> <li>双向数据流，值和 UI 绑定，但由于各种数据相互依赖相互绑定，导致数据问题的源头难以被跟踪到</li></ul> <p>Vue 虽然通过 v-model 支持双向绑定，但是如果引入了类似 redux 的 vuex，就无法同时使用 v-model。</p> <p>双绑跟单向绑定之间的差异只在于，双向绑定把数据变更的操作隐藏在框架内部，调用者并不会直接感知。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>something<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 等价于以下内容 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>something<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>something = $event.target.value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>也就是说，你只需要在组件中声明一个 name 为 value 的 props，并且通过触发 input 事件传入一个值，就能修改这个 value。</p> <h2 id="前端路由实现方式"><a href="#前端路由实现方式" aria-hidden="true" class="header-anchor">#</a> 前端路由实现方式</h2> <p>两种实现前端路由的方式</p> <ul><li>HTML5 History 两个新增的 API：history.pushState 和 history.replaceState，两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。</li> <li>Hash 就是 url 中看到 # ,我们需要一个根据监听哈希变化触发的事件( hashchange) 事件。我们用 window.location 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。</li></ul> <p>可以为 hash 的改变添加监听事件：</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'hashchange'</span><span class="token punctuation">,</span> funcRef<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
</code></pre></div><p>优点</p> <ul><li>从性能和用户体验的层面来比较的话，后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。而前端路由在访问一个新页面的时候仅仅是变换了一下路径而已，没有了网络延迟，对于用户体验来说会有相当大的提升。</li> <li>前端路由的优点有很多，比如页面持久性，像大部分音乐网站，你都可以在播放歌曲的同时，跳转到别的页面而音乐没有中断，再比如前后端彻底分离。
开发一个前端路由，主要考虑到页面的可插拔、页面的生命周期、内存管理等。</li></ul> <p>缺点</p> <ul><li>使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存。</li> <li>History interface 提供了两个新的方法：<code>pushState()</code>, <code>replaceState()</code>使得我们可以对浏览器历史记录栈进行修改：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span>stateObject<span class="token punctuation">,</span> title<span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">)</span>
window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span>stateObject<span class="token punctuation">,</span> title<span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">)</span>
</code></pre></div></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/front-end/css.html" class="prev">
          CSS
        </a></span> <span class="next"><a href="/front-end/fe-ngineering.html">
          前端工程化
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/13.b419daba.js" defer></script><script src="/assets/js/app.17e7384b.js" defer></script>
  </body>
</html>
