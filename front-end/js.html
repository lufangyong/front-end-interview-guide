<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS | 面试指南</title>
    <meta name="description" content="">
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.cc2a2ebf.css" as="style"><link rel="preload" href="/assets/js/app.17e7384b.js" as="script"><link rel="preload" href="/assets/js/15.f4550f65.js" as="script"><link rel="prefetch" href="/assets/js/13.b419daba.js"><link rel="prefetch" href="/assets/js/2.cda51ec0.js"><link rel="prefetch" href="/assets/js/3.ef3ee796.js"><link rel="prefetch" href="/assets/js/4.2e46cd24.js"><link rel="prefetch" href="/assets/js/5.bec878ff.js"><link rel="prefetch" href="/assets/js/6.539a2935.js"><link rel="prefetch" href="/assets/js/7.22ed9e45.js"><link rel="prefetch" href="/assets/js/8.7646f7cd.js"><link rel="prefetch" href="/assets/js/9.7f41828b.js"><link rel="prefetch" href="/assets/js/10.dc5d0640.js"><link rel="prefetch" href="/assets/js/11.194957a4.js"><link rel="prefetch" href="/assets/js/12.9ae0f5ed.js"><link rel="prefetch" href="/assets/js/14.e6b680b7.js"><link rel="prefetch" href="/assets/js/16.6c41112e.js"><link rel="prefetch" href="/assets/js/17.f5236e37.js"><link rel="prefetch" href="/assets/js/18.7b2decb8.js"><link rel="prefetch" href="/assets/js/19.45ef936f.js"><link rel="prefetch" href="/assets/js/20.b6776b5a.js"><link rel="prefetch" href="/assets/js/21.5ddbd38c.js"><link rel="prefetch" href="/assets/js/22.d6bb9334.js"><link rel="prefetch" href="/assets/js/23.17390f50.js"><link rel="prefetch" href="/assets/js/24.3b2112ec.js"><link rel="prefetch" href="/assets/js/25.b6fac30f.js"><link rel="prefetch" href="/assets/js/26.dbe699e8.js"><link rel="prefetch" href="/assets/js/27.3f5a9dee.js"><link rel="prefetch" href="/assets/js/28.3514e3df.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cc2a2ebf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">面试指南</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end/" class="nav-link router-link-active">前端</a></div><div class="nav-item"><a href="/calculation/" class="nav-link">计算机基础</a></div><div class="nav-item"><a href="/interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="https://github.com/lufangyong" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end/" class="nav-link router-link-active">前端</a></div><div class="nav-item"><a href="/calculation/" class="nav-link">计算机基础</a></div><div class="nav-item"><a href="/interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="https://github.com/lufangyong" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/front-end/" class="sidebar-link">前端</a></li><li><a href="/front-end/js.html" class="active sidebar-link">JS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end/js.html#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#创建对象" class="sidebar-link">创建对象</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#原型链" class="sidebar-link">原型链</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#instanceof" class="sidebar-link">instanceof</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#isprototypeof" class="sidebar-link">isPrototypeOf</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#hasownproperty" class="sidebar-link">hasOwnProperty</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#new-运算符" class="sidebar-link">new 运算符</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#作用域链" class="sidebar-link">作用域链</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#js-继承方式" class="sidebar-link">js 继承方式</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#类与实例" class="sidebar-link">类与实例</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#类与继承" class="sidebar-link">类与继承</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#async-和-defer" class="sidebar-link">async 和 defer</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#import-与-require" class="sidebar-link">import 与 require</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#promise-实现原理" class="sidebar-link">Promise 实现原理</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#apply、call-和-bind" class="sidebar-link">apply、call 和 bind</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#异步函数" class="sidebar-link">异步函数</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#观察者模式" class="sidebar-link">观察者模式</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#什么是同构" class="sidebar-link">什么是同构</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#es6" class="sidebar-link">ES6</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end/js.html#let-与-var-和-const" class="sidebar-link">let 与 var 和 const</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#箭头函数" class="sidebar-link">箭头函数</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#symbol，map-和-set" class="sidebar-link">Symbol，Map 和 Set</a></li><li class="sidebar-sub-header"><a href="/front-end/js.html#proxy-代理" class="sidebar-link">proxy(代理)</a></li></ul></li></ul></li><li><a href="/front-end/browser.html" class="sidebar-link">Browser</a></li><li><a href="/front-end/css.html" class="sidebar-link">CSS</a></li><li><a href="/front-end/frame.html" class="sidebar-link">框架</a></li><li><a href="/front-end/fe-ngineering.html" class="sidebar-link">前端工程化</a></li><li><a href="/front-end/performance.html" class="sidebar-link">前端性能优化</a></li><li><a href="/front-end/http.html" class="sidebar-link">http</a></li><li><a href="/front-end/safe.html" class="sidebar-link">安全</a></li><li><a href="/front-end/design-pattern.html" class="sidebar-link">设计模式</a></li><li><a href="/front-end/node.html" class="sidebar-link">Node</a></li><li><a href="/front-end/recommend.html" class="sidebar-link">学习资源</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="js"><a href="#js" aria-hidden="true" class="header-anchor">#</a> JS</h1> <h2 id="闭包"><a href="#闭包" aria-hidden="true" class="header-anchor">#</a> 闭包</h2> <p>特性：</p> <ol><li>函数嵌套函数</li> <li>函数内部可以引用外部的参数和变量</li> <li>参数和变量不会被垃圾回收机制回收</li></ol> <p>闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p> <p>为什么要使用闭包：</p> <ol><li>为了设计私有方法和变量，避免全局变量污染</li> <li>希望一个变量长期驻扎在内存中</li></ol> <p><a href="https://segmentfault.com/a/1190000000652891" target="_blank" rel="noopener noreferrer">详解 js 闭包<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="创建对象"><a href="#创建对象" aria-hidden="true" class="header-anchor">#</a> 创建对象</h2> <p>第一种：字面量</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'o1'</span> <span class="token punctuation">}</span>
<span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'o2'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>第二种：构造函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">M</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token keyword">var</span> o3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token string">'o3'</span><span class="token punctuation">)</span>
</code></pre></div><p>第三种：Object.create</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'o1'</span> <span class="token punctuation">}</span>
<span class="token keyword">var</span> o4 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
</code></pre></div><h2 id="原型链"><a href="#原型链" aria-hidden="true" class="header-anchor">#</a> 原型链</h2> <p>原型链是由原型、构造函数、实例三者构成
<img src="/prototype.png" alt="foo"></p> <ul><li>构造函数有原型对象</li> <li>原型对象也是函数，也会有原型对象</li> <li>构造函数访问原型对象 <code>Fun.prototype</code></li> <li>原型对象访问构造函数 <code>Fun.prototype.constructor</code></li> <li>实例化对象 <code>new Fun()</code></li> <li>实例访问它的构造函数的原型对象 <code>fn.__proto__</code></li> <li>构造函数也是函数，它也有构造函数<code>Function</code>, 是它的实例</li></ul> <p>示例代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">M</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> f1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 构造函数的原型对象 --&gt; 实例的原型对象</span>
<span class="token constant">M</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> f1<span class="token punctuation">.</span>__proto__
<span class="token comment">// 构造函数的原型对象的构造器 --&gt; 构造函数</span>
<span class="token constant">M</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> <span class="token constant">M</span>
<span class="token comment">//构造函数也是函数，它的构造函数是Function，是它的实例对象，实例就会有__proto__</span>
<span class="token constant">M</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Function<span class="token punctuation">.</span>prototype
</code></pre></div><h2 id="instanceof"><a href="#instanceof" aria-hidden="true" class="header-anchor">#</a> instanceof</h2> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>instanceof 运算符用来判断一个构造函数的 prototype 属性所指向的对象是否存在另外一个要检测对象的原型链上</p></div> <ul><li>确定原型和实例之间的关系</li> <li>用来判断某个构造函数的 prototype(原型)属性是否存在另外一个要检测对象的原型链上</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
o <span class="token keyword">instanceof</span> <span class="token class-name">C</span> <span class="token comment">// true 因为Object.getPrototypeOf(o) === C.prototype</span>
</code></pre></div><p>instanceof 只能用来判断对象和函数，不能用来判断字符串和数字</p> <h2 id="isprototypeof"><a href="#isprototypeof" aria-hidden="true" class="header-anchor">#</a> isPrototypeOf</h2> <p>作用：检测一个对象是否是另一个对象的原型。或者说一个对象是否被包含在另一个对象的原型链中</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span> <span class="token comment">// 定义一个原型对象</span>
<span class="token keyword">var</span> o <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment">// 使用这个原型创建一个对象</span>
p<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token comment">//=&gt;true：o继承p</span>
Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment">// =&gt; true p继承自Object.prototype</span>
</code></pre></div><h2 id="hasownproperty"><a href="#hasownproperty" aria-hidden="true" class="header-anchor">#</a> hasOwnProperty</h2> <p>检测集合成员的所属关系，判断某个属性是否存在于某个对象中。可以通过 in 运算符，hasOwnProperty()来完成</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 定义Animal构造函数</span>
<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 定义Animal原型</span>
Animal<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  species<span class="token punctuation">:</span> <span class="token string">'动物'</span><span class="token punctuation">,</span>
  say<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'i can say word'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 定义构造函数Cat</span>
<span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color
<span class="token punctuation">}</span>
<span class="token keyword">var</span> <span class="token function-variable function">F</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token constant">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Animal<span class="token punctuation">.</span>prototype
Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Cat <span class="token comment">// Cat继承Animal 用F空对象作为媒介</span>

<span class="token keyword">var</span> eh <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'lili'</span><span class="token punctuation">,</span> <span class="token string">'white'</span><span class="token punctuation">)</span> <span class="token comment">// 实例化对象</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'say'</span> <span class="token keyword">in</span> eh<span class="token punctuation">)</span> <span class="token comment">// =&gt;true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'name'</span> <span class="token keyword">in</span> eh<span class="token punctuation">)</span> <span class="token comment">// =&gt;true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'color'</span> <span class="token keyword">in</span> eh<span class="token punctuation">)</span> <span class="token comment">// =&gt;true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'species'</span> <span class="token keyword">in</span> eh<span class="token punctuation">)</span> <span class="token comment">// =&gt;true</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>eh<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'say'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// =&gt;false  由于say为继承属性  非自有属性</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>eh<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'species'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// =&gt;false 由于species为继承属性  非自有属性</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>eh<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// =&gt;true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>eh<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'color'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// =&gt;true</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> eh<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>eh<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// =&gt;species  say name  color</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="new-运算符"><a href="#new-运算符" aria-hidden="true" class="header-anchor">#</a> new 运算符</h2> <ul><li>一个对象被创建，它继承自 foo.prototype</li> <li>构造函数 foo 被执行，执行的时候，相应的传参会被传入，同时上下文(this)会被指定为这个新实例。new foo 等同于 new foo()，只能在用不传递任何参数的情况</li> <li>如果构造函数返回了一个对象，那么这个对象会取代整个 new 出来的结果，如果构造函数没有返回对象，那么 new 出来的结果为继承 foo.prototype</li></ul> <p>模拟 new 操作符的背后实现的原理</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">new2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 继承它的原型对象</span>
  <span class="token keyword">var</span> o <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>func<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
  <span class="token comment">// 改变它的上下文</span>
  <span class="token keyword">var</span> k <span class="token operator">=</span> func<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>
  <span class="token comment">// 如果构造函数返回的是对象就返回这个对象，不是就直接返回继承原型的对象</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> k <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> k
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> o
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="作用域链"><a href="#作用域链" aria-hidden="true" class="header-anchor">#</a> 作用域链</h2> <ul><li>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的</li> <li>作用域链的变量只能向上访问</li> <li>变量访问到 window 对象即被终止</li> <li>作用域链向下访问变量是不被允许的</li></ul> <h2 id="js-继承方式"><a href="#js-继承方式" aria-hidden="true" class="header-anchor">#</a> js 继承方式</h2> <ul><li>原型链继承的缺点</li> <li>一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。</li> <li>借用构造函数（类式继承）
<ul><li>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承</li></ul></li> <li>组合式继承
<ul><li>组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</li></ul></li></ul> <p><strong>如果如不用 es6，比较好的继承方式：</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Object.create只兼容到ie9</span>
<span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>create<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token constant">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义一个动物类</span>
<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token comment">// 实例方法</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sleep</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'正在睡觉！'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Animal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  Cat<span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Tom'</span>
<span class="token punctuation">}</span>
<span class="token comment">// 创建一个独立而且又继承了父类的原型对象</span>
Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
</code></pre></div><p><a href="https://segmentfault.com/a/1190000002440502" target="_blank" rel="noopener noreferrer">JavaScript 继承方式详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="类与实例"><a href="#类与实例" aria-hidden="true" class="header-anchor">#</a> 类与实例</h2> <p>类的声明</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">Animal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Animal'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>es6 中 class 的声明</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Animal2</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Animal2'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>生成实例</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">Animal2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="类与继承"><a href="#类与继承" aria-hidden="true" class="header-anchor">#</a> 类与继承</h2> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>万变不离其宗，实现类的继承的原理就是使用原型链的特性，没有原型就不会有构造函数，所以理解原型链是基础</p></div> <ul><li>借助构造函数实现继承</li> <li>实现的原理：在子类中执行父类，并且改变 this 的指向，把父类的属性和方法挂载到子类中</li> <li>缺点：只能部分继承，继承父类构造函数里面的属性和方法，无法继承父类原型链中的属性和方法</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'parent1'</span>
<span class="token punctuation">}</span>
Parent1<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Parent1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// apply</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'child1'</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Child1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Child1<span class="token punctuation">.</span>say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 这里会报错，Child1没有say方法</span>
</code></pre></div><ul><li>借助原型链实现继承</li> <li>实现原理：把父类中的实例化对象赋值给子类中的原型</li> <li>new Child2.<strong>proto</strong> = Child2.prototype</li> <li>Child2.prototype = new Parent2();</li> <li>所以实例子类就是变相的实例父类</li> <li>实例子类的原型最终指向父类</li> <li>缺点：子类的原型对象都指向同一个，这是不符合我们的需求的，改变一个，都会改变，失却了面向对象的意义</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token constant">P</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'patent2'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'child2'</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Child2<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">var</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s1<span class="token punctuation">.</span>paly<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 改变s1中的say方法，s2也被改变了</span>
<span class="token comment">// 因为它们共用一个原型对象</span>
<span class="token comment">// s1.__proto === s2.__proto true</span>
</code></pre></div><ul><li>组合方式</li> <li>结合前面两种方式的继承</li> <li>解决它们之间的缺点</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'patent3'</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Parent3<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'child3'</span>
<span class="token punctuation">}</span>
<span class="token comment">// 创建出一个独立而且又继承了父类的原型对象</span>
Child3<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Parent3<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
<span class="token comment">//Child3.prototype = Parent3.prototype 使用的是同一个父类的原型对象，没有独立开来</span>
<span class="token comment">// 改变子类中的constructor的指向</span>
Child3<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child3
</code></pre></div><h2 id="async-和-defer"><a href="#async-和-defer" aria-hidden="true" class="header-anchor">#</a> async 和 defer</h2> <p>相同：</p> <ul><li><code>defer</code>与<code>async</code>的相同点是采用并行下载，在下载过程中不会产生阻塞。</li></ul> <p>不同：</p> <ul><li>在于执行时机，<code>async</code>是加载完成后自动执行，而<code>defer</code>需要等待页面完成后执行。</li></ul> <h2 id="import-与-require"><a href="#import-与-require" aria-hidden="true" class="header-anchor">#</a> import 与 require</h2> <p>es6 的导入 import 导出 exports 与 require、module.exports 的区别?</p> <ul><li>ES6 Module 中导入模块的属性或者方法是强绑定的，包括基础类型；而 CommonJS 则是普通的值传递或者引用传递。</li> <li>CommonJS 模块是运行时的，导入导出是通过值的复制来达成的。ES6 的模块是静态的，导入导出实际上是建立符号的映射</li> <li>import 必须放在文件最顶部，require 不需要；import 最终会被 babel 编译为 require</li></ul> <h2 id="promise-实现原理"><a href="#promise-实现原理" aria-hidden="true" class="header-anchor">#</a> Promise 实现原理</h2> <p>现在回顾下 Promise 的实现过程，其主要使用了设计模式中的观察者模式：</p> <ul><li>通过<code>Promise.prototype.then</code>和<code>Promise.prototype.catch</code>方法将观察者方法注册到被观察者 Promise 对象中，同时返回一个新的 Promise 对象，以便可以链式调用。</li> <li>被观察者管理内部 pending、fulfilled 和 rejected 的状态转变，同时通过构造函数中传递的 resolve 和 reject 方法以主动触发状态转变和通知观察者。</li> <li><code>Promise.then()</code>是异步调用的，这也是 Promise 设计上规定的，其原因在于同步调用和异步调用同时存在会导致混乱。</li> <li>为了暂停当前的 promise，或者要它等待另一个 promise 完成，只需要简单地在 then() 函数中返回另一个 promise。</li></ul> <p>Promise 的缺点</p> <ul><li>首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</li> <li>其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</li> <li>第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul> <p>一般来说，不要在 then 方法里面定义 Reject 状态的回调函数（即 then 的第二个参数），总是使用 catch 方法，理由是更接近同步的写法。
then 的第二个函数参数和 catch 等价</p> <p><strong>Promise.all 和 Promise.race 的区别？</strong></p> <ul><li>Promise.all 把多个 promise 实例当成一个 promise 实例,当这些实例的状态都发生改变时才会返回一个新的 promise 实例，才会执行 then 方法。</li> <li>Promise.race 只要该数组中的 Promise 对象的状态发生变化（无论是 resolve 还是 reject）该方法都会返回。</li></ul> <h2 id="apply、call-和-bind"><a href="#apply、call-和-bind" aria-hidden="true" class="header-anchor">#</a> apply、call 和 bind</h2> <p>三者都可以把一个函数应用到其他对象上:</p> <ul><li>call、apply 是修改函数的作用域（修改 this 指向），并且立即执行</li> <li>bind 是返回了一个新的函数，不是立即执行</li> <li>apply 和 call 的区别是 apply 接受数组作为参数</li> <li>call 是接受逗号分隔的无限多个参数列表</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">getMax</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Math<span class="token punctuation">.</span>max<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">//call</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">//{id: 42}</span>
<span class="token punctuation">}</span>

foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>如果该方法是非严格模式代码中的函数，则 null 和 undefined 将替换为全局对象，并且原始值将被包装。
当你调用 apply 传递给它 null 时，就像是调用函数而不提供任何对象</p> <h2 id="异步函数"><a href="#异步函数" aria-hidden="true" class="header-anchor">#</a> 异步函数</h2> <p>async，Promise，Generator 函数，co 函数库区别</p> <ul><li><code>async...await</code>写法最简洁，最符合语义。</li> <li>async/await 让异步代码看起来、表现起来更像同步代码，这正是其威力所在。</li> <li>async 函数就是 Generator 函数的语法糖，只不过 async 内置了自动执行器。async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await</li></ul> <p><strong>async 函数优点</strong></p> <ol><li>Generator 函数必须靠执行器，所以才有 CO 函数库，async 函数自带执行器</li> <li>更好的语义</li> <li>更广的适用性。co 函数库 yield 后面只能是 Thunk 函数或者 Promise 对象，await 后面可以跟 Promise 对象和原始类型值（等同于同步操作）</li> <li>Generator 函数：可以把它理解成一个函数的内部状态的遍历器，Generator 重点在解决异步回调金字塔问题，巧妙的使用它可以写出看起来同步的代码。</li></ol> <h2 id="观察者模式"><a href="#观察者模式" aria-hidden="true" class="header-anchor">#</a> 观察者模式</h2> <p>JS 里对观察者模式的实现是通过回调来实现的，，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象</p> <p>观察者模式：</p> <ul><li>对程序中某一个对象的进行实时的观察，当该对象状态发生改变的时候 进行通知</li> <li>我们为什么要用观察者模式呢，主要是可以实现松散耦合的代码，什么意思？就是</li> <li>主体和订阅者之间是相互独立的，其二者可以独立运行。</li></ul> <h2 id="什么是同构"><a href="#什么是同构" aria-hidden="true" class="header-anchor">#</a> 什么是同构</h2> <p>同构(isomorphic/universal)就是使前后端运行同一套代码的意思，后端一般是指 NodeJS 环境。</p> <h2 id="es6"><a href="#es6" aria-hidden="true" class="header-anchor">#</a> ES6</h2> <h3 id="let-与-var-和-const"><a href="#let-与-var-和-const" aria-hidden="true" class="header-anchor">#</a> let 与 var 和 const</h3> <ul><li>let 为 ES6 新添加申明变量的命令，它类似于 var，但是有以下不同：</li> <li>let 命令不存在变量提升，如果在 let 前使用，会导致报错</li> <li>暂时性死区的本质，其实还是块级作用域必须“先声明后使用”的性质。</li> <li>let，const 和 class 声明的全局变量不是全局对象的属性。</li></ul> <p>const 声明的变量与 let 声明的变量类似，它们的不同之处在于，const 声明的变量只可以在声明时赋值，不可随意修改，否则会导致 SyntaxError（语法错误）。</p> <p>const 只是保证变量名指向的地址不变，并不保证该地址的数据不变。const 可以在多个模块间共享</p> <p>let 暂时性死区的原因：var 会变量提升，let 不会。</p> <h3 id="箭头函数"><a href="#箭头函数" aria-hidden="true" class="header-anchor">#</a> 箭头函数</h3> <ul><li>箭头函数不属于普通的 function，所以没有独立的上下文。箭头函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</li> <li>由于箭头函数没有自己的 this，函数对象中的 call、apply、bind 三个方法，无法&quot;覆盖&quot;箭头函数中的 this 值。</li> <li>箭头函数没有原本(传统)的函数有的隐藏 arguments 对象。</li> <li>箭头函数不能当作 generators 使用，使用 yield 会产生错误。</li></ul> <p>在以下场景中不要使用箭头函数去定义：</p> <ul><li>定义对象方法、定义原型方法、定义构造函数、定义事件回调函数。</li> <li>箭头函数里不但没有 this，也没有 arguments, super ……</li></ul> <h3 id="symbol，map-和-set"><a href="#symbol，map-和-set" aria-hidden="true" class="header-anchor">#</a> Symbol，Map 和 Set</h3> <ul><li>Map 对象保存键值对。一个对象的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li> <li>Set 对象允许你存储任何类型的唯一值，Set 对象是值的集合，Set 中的元素只会出现一次</li> <li>Symbol 是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用(Symbol([description]) )</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> mySet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
mySet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
mySet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
mySet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mySet<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token comment">//2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mySet<span class="token punctuation">)</span> <span class="token comment">//Set {1,'hello'}</span>

<span class="token comment">//Map保存键值对也不能有重复的</span>
<span class="token keyword">let</span> myMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> key1 <span class="token operator">=</span> <span class="token string">'China'</span><span class="token punctuation">,</span>
  key2 <span class="token operator">=</span> <span class="token string">'America'</span>
myMap<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>key1<span class="token punctuation">,</span> <span class="token string">'welcome'</span><span class="token punctuation">)</span>
myMap<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>key2<span class="token punctuation">,</span> <span class="token string">'gold bless you'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMap<span class="token punctuation">)</span> <span class="token comment">//Map { 'China' =&gt; 'welcome', 'America' =&gt; 'gold bless you' }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMap<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>key1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//welcome</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMap<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>key2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//gold bless you</span>

<span class="token keyword">let</span> mySymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'symbol1'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> mySymbol2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'symbol1'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mySymbol <span class="token operator">==</span> mySymbol2<span class="token punctuation">)</span> <span class="token comment">//false</span>
<span class="token comment">//Symbols 在 for...in 迭代中不可枚举。</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
obj<span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'c'</span>
obj<span class="token punctuation">.</span>d <span class="token operator">=</span> <span class="token string">'d'</span>
obj<span class="token punctuation">[</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span>
obj<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'b'</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token comment">//logs 'c' and 'd'</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>for...of</code>可以用来遍历数组，类数组对象，argument，字符串，Map 和 Set，<code>for...in</code>用来遍历对象</p> <h3 id="proxy-代理"><a href="#proxy-代理" aria-hidden="true" class="header-anchor">#</a> proxy(代理)</h3> <p>Proxy(代理) 是 ES6 中新增的一个特性。Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。</p> <p>使用 Proxy 的好处是：</p> <ul><li>对象只需关注于核心逻辑，一些非核心的逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）可以让 Proxy 来做。</li> <li>从而达到关注点分离，降级对象复杂度的目的。</li></ul> <p>使用方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
</code></pre></div><p>其中，target 为被代理对象。handler 是一个对象，其声明了代理 target 的一些操作。p 是代理后的对象。</p> <p>当外界每次对 p 进行操作时，就会执行 handler 对象上的一些方法。handler 能代理的一些常用的方法如下：</p> <ul><li>get：读取</li> <li>set：修改</li> <li>has：判断对象是否有该属性</li> <li>construct：构造函数</li></ul> <p>使用场景：</p> <ul><li>实现私有变量</li> <li>抽离校验模块</li></ul> <p>实现私有变量，实现了真正的私有变量。代理中把以 _ 开头的变量都认为是私有的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> api <span class="token operator">=</span> <span class="token punctuation">{</span>
  _secret<span class="token punctuation">:</span> <span class="token string">'xxxx'</span><span class="token punctuation">,</span>
  _otherSec<span class="token punctuation">:</span> <span class="token string">'bbb'</span><span class="token punctuation">,</span>
  ver<span class="token punctuation">:</span> <span class="token string">'v0.0.1'</span>
<span class="token punctuation">}</span>

api <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>api<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 以 _ 下划线开头的都认为是 私有的</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'_'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'私有变量不能被访问'</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'_'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'私有变量不能被修改'</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  has<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> key<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'_'</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token punctuation">:</span> key <span class="token keyword">in</span> target
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

api<span class="token punctuation">.</span>_secret <span class="token comment">// 私有变量不能被访问</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>api<span class="token punctuation">.</span>ver<span class="token punctuation">)</span> <span class="token comment">// v0.0.1</span>
api<span class="token punctuation">.</span>_otherSec <span class="token operator">=</span> <span class="token number">3</span> <span class="token comment">// 私有变量不能被修改</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'_secret'</span> <span class="token keyword">in</span> api<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ver'</span> <span class="token keyword">in</span> api<span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><p>抽离校验模块，实现了在代理中实现设置属性值前做验证。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">createValidator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> animalValidator<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> animalValidator <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 动物的名字必须是字符串类型的</span>
    <span class="token keyword">return</span> <span class="token keyword">typeof</span> name <span class="token operator">===</span> <span class="token string">'string'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">createValidator</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> validator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>validator<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 符合验证条件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>validator<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Cannot set </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> to </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">. Invalid.`</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
dog<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'dog'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
dog<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token number">123</span> <span class="token comment">// Uncaught Error: Cannot set name to 123. Invalid.</span>
</code></pre></div></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/front-end/" class="prev router-link-active">
          前端
        </a></span> <span class="next"><a href="/front-end/browser.html">
          Browser
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/15.f4550f65.js" defer></script><script src="/assets/js/app.17e7384b.js" defer></script>
  </body>
</html>
